
#=================================================================================================================================
# $ gmic -m custom.gmic -clut_from_customKeypoints src.png,dst.png,out_folder,clut_name,uniformSampling,keypoints_influence,cube_resolution
# e.g. gmic -m custom.gmic clut_from_customKeypoints dropBox/IN/keypoints_+1_apple_IT8.png,dropBox/IN/keypoints_+1_canon_IT8.png,dropBox/OUT/,IT8.png,3,100,64
# TODO: keypoints_influence is not as effective as it should (compared to "clut_from_ab" command) and needs to be investigated further

clut_from_customKeypoints :
v + 

# Add user-defined color correspondences
-input $1 if $!==2 rm. fi #remove thumbnail img
-input $2 if $!==3 rm. fi #remove thumbnail img

cube_resolution=$7 # 64 is a good tradeoff: higher than 64 takes more computational time but cld improve very close keypoints
cube_resolution1={$cube_resolution-1} 
i[0] $cube_resolution,$cube_resolution,$cube_resolution,4 

uniformSampling=$5 # choice{0,"None","8 Keypoints (RGB Corners)","27 Keypoints","64 Keypoints","125 Keypoints","216 Keypoints","343 Keypoints"},
if $uniformSampling # Lock uniform sampling
  uniform_distribution {(1+$uniformSampling)^3},3 
  repeat 
    w point[0] {round($cube_resolution1*I[$>])},1,{255*I[$>]},1 
  done 
  rm.
fi

-rotate[-1,-2] -90
nb_keypoints={w} 
repeat $nb_keypoints
  mode=2 # choice{"ignore","lock", "replace"} TODO: extend the script to take "mode" from the 3th column of the user-defined color correspondences img 
  if $mode # if not ignore (lock or replace)
    tRGB=[{I(#-1,$>)}]
    #echo {$tRGB}
    sRGB=[{I(#-2,$>)}]
    xyz={round(($cube_resolution1/255)*$sRGB)}
    if $mode==2 pixel_RGB=$tRGB else pixel_RGB=$sRGB fi

    point[0] $xyz,1,{$pixel_RGB},1 
  fi
done
-rotate[-1,-2] 90

keypoints_influence=$6
l[0]
  s c,-3
  # create a weighting map image and move it to [0]
  if $keypoints_influence<100 # Need to compute a weighting map.
    +distance. 1
    if $keypoints_influence ^. {1/(0.05+4*$keypoints_influence%)} else f. 0 fi
    n. 0,1 nm. influence mv. -3
  fi
  ==. 0 # generate the mask
  inpaint_pde.. .,100%,1,20 #Inpaint image [1] by mask ., using a multiscale diffusion algorithm with 100% scales (Smoothness) and 20 iterations of delaunay-guided diffusion.
  rm. # remove the mask

  if $keypoints_influence<100 # using "if {$influence}" instead is buggy!
    100%,100%,100%,3,[x,y,z] #Input image at position 2, with values '[x,y,z]' (1 image 64x64x64x3).
    n. 0,255 #Normalize image [2] in range [0,255], with constant-case ratio 0.
    j. ..,0,0,0,0,1,...  #Draw image [1] at (0,0,0,0) on image [2], with opacity 1 and mask [0].
    rm[-3,-2]  #Remove images [0,1] (1 image left).
  fi
endl

clut_write_n_plot $0,$3,$4,$5,$6,$7
v -

#=================================================================================================================================
# $ gmic -m custom.gmic -clut_from_ab src.tif,dst.tif,out_folder,clut_name,uniformSampling,keypoints_influence,cube_resolution
# e.g. gmic -m custom.gmic clut_from_ab srcImg.tif,srcImg_color_corrected_Humphrey.tif,./,lut.png,3,100,64

clut_from_ab :
v + 
-input $1 if $!==2 rm. fi #remove thumbnail img
-input $2 if $!==3 rm. fi #remove thumbnail img


#-fx_clut_from_ab 2,4,$3,$4,$5
cube_resolution=$7 # 64 is a good tradeoff: higher than 64 takes more computational time but cld improve very close keypoints
cube_resolution1={$cube_resolution-1} 
i[0] $cube_resolution,$cube_resolution,$cube_resolution,4 # {a=$cube_resolution;[a,a,a]},4 #Input black image at position 0.

uniformSampling=$5 # choice{0,"None","8 Keypoints (RGB Corners)","27 Keypoints","64 Keypoints","125 Keypoints","216 Keypoints","343 Keypoints"},
if $uniformSampling # Lock uniform sampling
  uniform_distribution {(1+$uniformSampling)^3},3 
  repeat 
    w point[0] {round($cube_resolution1*I[$>])},1,{255*I[$>]},1 
  done 
  rm.
fi

f[2] ">I(#0,round(I(#1)*(w#0-1)/255))+=[R,G,B,1]; I" #Fill image [2] with expression '>I(#0,round(I(#1)*(w#0-1)/255))+=[R,G,B,1]; I'. #If the specified expression starts with ’>’ or ’<’, the pixel access operators ’i(), i[], j()’ and ’j[]’ return values of the image being currently modified,in forward (’>’) or backward (’<’) order. The multi−threading evaluation of the expression is also disabled in this case.

keypoints_influence=$6
l[0]
  s c,-3
  +max. 1
  /[-3,-1] # Divide images [0,2] (will rm img 2)
  ==. 0 #Compute boolean equality between image [1] and 0 (put the result in img 1). This is the mask for inpainting
  inpaint_pde.. .,100%,1,20 #Inpaint image [0] by mask ., using a multi-scale diffusion algorithm with 75% scales (Smoothness) and 20 iterations of delaunay-guided diffusion.
  distance. 0 #Compute distance map to isovalue 0 in image [1], with euclidean metric (put the result in img 1).
  if $keypoints_influence>0
    *. {-1/$keypoints_influence} # Multiply image [1] by {-1/(1+$keypoints_influence)}. Influence of Color Samples applied here ($6) 
  else
    *. -1
  fi
  exp. #Compute pointwise exponential of image [1].
  f.. "f = i(#-1); f*I + (1-f)*[x,y,z]*255/(w-1)" #Fill image [0] with expression 'f = i(#-1); f*I + (1-f)*[x,y,z]*255/(w-1)' 
  rm.
endl

clut_write_n_plot $0,$3,$4,$5,$6,$7
v -

#=================================================================================================================================
# $ gmic -m custom.gmic -clut_write_n_plot method,out_folder,clut_name,uniformSampling,keypoints_influence,cube_resolution
# e.g. gmic -m custom.gmic clut_from_ab srcImg.tif,srcImg_color_corrected_Humphrey.tif,./,lut.png,3,100,64

clut_write_n_plot :
v + 

out_folder=$2
clut_name=$1_$3
uniformSampling=$4
keypoints_influence=$5
cube_resolution=$6

is_png={str=lowercase(['$clut_name']);find(str,'.png')==size(str)-4}
is_cube={str=lowercase(['$clut_name']);find(str,'.cube')==size(str)-5}
if !$is_png" && "!$is_cube $!is_ciube error "Filename extension must be '.cube' or '.png'." fi

strreplace '$clut_name','.png','' # buggy
e $clut_name

if $is_png # Warning: by saving in a 512x512 image, we loose some precision. The highest precision can be acheived by setting the cube resolution to higher than 64 and saving in cube format or bigger image dimention if possible.
  if {0,w!=64} r[0] 64,64,64,3,3 fi
  r[0] {0,r=round(whd^0.5);[r,r]},1,3,-1 #Resize image [0] to 512x512x1x3, with no interpolation, dirichlet boundary conditions and alignment (0,0,0,0).
  o[0] $out_folder/lut_uniformSampling{$uniformSampling}_keypoints_influence{$keypoints_influence}_cube_resolution{$cube_resolution}_$clut_name
else
  #if {0,w>32} r3dx[0] 32 fi # uncomment this line for less accurate mapping but a lighter file size
  output_cube[0] $out_folder/lut_uniformSampling{$uniformSampling}_keypoints_influence{$keypoints_influence}_cube_resolution{$cube_resolution}_$clut_name
fi

map_clut.. [0] # Apply CLUT
-d # if all went well, then last 2 images should be almost identical!
rm[^0]
#visualize the cube (Get 3D color distribution of the LUT)
distribution3d colorcube3d primitives3d 1 add3d
v -