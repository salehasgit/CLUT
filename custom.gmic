
#=================================================================================================================================
# $ gmic -m custom.gmic -generate_CLUT keypoints.png,uniformSampling,keypoint_influence
generate_CLUT :
v + 
cube_resolution=64
cube_resolution1={$cube_resolution-1} 
$cube_resolution,$cube_resolution,$cube_resolution,4 

uniformSampling=$2 # choice{0,"None","8 Keypoints (RGB Corners)","27 Keypoints","64 Keypoints","125 Keypoints","216 Keypoints","343 Keypoints"},
if $uniformSampling # Lock uniform sampling
  uniform_distribution {(1+$uniformSampling)^3},3 
  repeat 
  w point.. {round($cube_resolution1*I[$>])},1,{255*I[$>]},1 
  done 
  rm.
fi

-input $1 # Add user-defined color correspondences
s. x 
-rotate[-1,-2] -90
nb_keypoints={w} 
repeat $nb_keypoints
  mode=2 # choice{"ignore","lock", "replace"} TODO: extend the script to take "mode" from the 3th column of the user-defined color correspondences img 
  if $mode # if not ignore (lock or replace)
    tRGB=[{I(#-1,$>)}]
    #echo {$tRGB}
    sRGB=[{I(#-2,$>)}]
    xyz={round(($cube_resolution1/255)*$sRGB)}
    if $mode==2 pixel_RGB=$tRGB else pixel_RGB=$sRGB fi

    point[0] $xyz,1,{$pixel_RGB},1 
  fi
done

rm[-2,-1]
keypoint_influence=$3
s c,-3
# create a weighting map image and move it to [0]
if $keypoint_influence<100 # Need to compute a weighting map.
  +distance. 1
  if $keypoint_influence ^. {1/(0.05+4*$keypoint_influence%)} else f. 0 fi
  n. 0,1 nm. influence mv. -3
fi
==. 0 # generate the mask
inpaint_pde.. .,100%,1,20 #Inpaint image [1] by mask ., using a multiscale diffusion algorithm with 100% scales and 20 iterations of delaunay-guided diffusion.
rm. # remove the mask

if $keypoint_influence<100 # using "if {$influence}" instead is buggy!
  100%,100%,100%,3,[x,y,z] #Input image at position 2, with values '[x,y,z]' (1 image 64x64x64x3).
  n. 0,255 #Normalize image [2] in range [0,255], with constant-case ratio 0.
  j. ..,0,0,0,0,1,...  #Draw image [1] at (0,0,0,0) on image [2], with opacity 1 and mask [0].
  rm[-3,-2]  #Remove images [0,1] (1 image left).
fi

c. 0,255 

# save it as .cube
output_cube[-1] lut_uniformSampling{$uniformSampling}_keypoint_influence$keypoint_influence.cube

# Apply CLUT
-input $1
s. x
map_clut.. [0] # w/o spatial regularization
-d v - # if all went well, then last 2 images should be almost identical!

rm[-2,-1]
#convert to Haldclut png    
-r 64,64,64,3,3 -r 512,512,1,3,-1 -o lut_uniformSampling{$uniformSampling}_keypoint_influence$keypoint_influence.png

#visualize the cube (Get 3D color distribution of the LUT)
distribution3d colorcube3d primitives3d 1 add3d

#=================================================================================================================================
# $ gmic -m custom.gmic -generate_CLUT_beforeAfter src.tif,dst.tif,out_folder,clut_name,keypoints_influence
# TODO: keypoints_influence is playing a major role and needs to be investigated further
# e.g. gmic -m custom.gmic clut_from_ab srcImg.tif,srcImg_color_corrected_Humphrey.tif,./,lut.png,100

clut_from_ab :
v + 
-input $1 if $!==2 rm. fi #remove thumbnail img
-input $2 if $!==3 rm. fi #remove thumbnail img
mv. 0

#-fx_clut_from_ab 2,4,$3,$4,$5
cube_resolution=64
i[0] $cube_resolution,$cube_resolution,$cube_resolution,4 #== {a=$cube_resolution;[a,a,a]},4 #Input black image at position 0.
f[1] ">I(#0,round(I(#2)*(w#0-1)/255))+=[R,G,B,1]; I" #Fill image [1] with expression '>I(#0,round(I(#2)*(w#0-1)/255))+=[R,G,B,1]; I'.
-d
l[0]
  -d
  s c,-3
  +max. 1
  /[-3,-1] # Divide images [0,2] (will rm img 2)
  ==. 0 #Compute boolean equality between image [1] and 0 (put the result in img 1). This is the mask for inpainting
  inpaint_pde.. .,75%,1 
  distance. 0 #Compute distance map to isovalue 0 in image [1], with euclidean metric (put the result in img 1).
  *. {-1/(1+$5)} # Multiply image [1] by {-1/(1+$5)}. Influence of Color Samples applied here ($5) 
  exp. #Compute pointwise exponential of image [1].
  f.. "f = i(#-1); f*I + (1-f)*[x,y,z]*255/(w-1)" #Fill image [0] with expression 'f = i(#-1); f*I + (1-f)*[x,y,z]*255/(w-1)'
  rm.
  if w!=64 r. 64,64,64,3,3 fi
endl

is_png={str=lowercase(['"$4"']);find(str,'.png')==size(str)-4}
is_cube={str=lowercase(['"$4"']);find(str,'.cube')==size(str)-5}
if !$is_png" && "!$is_cube $!is_ciube error "Filename extension must be '.cube' or '.png'." fi
if $is_png 
  r[0] {0,r=round(whd^0.5);[r,r]},1,3,-1 o[0] "$3/$4"
else
  if {0,w>32} r3dx[0] 32 fi
  output_cube[0] "$3/$4"
fi
rm[0]
  
-input $3/$4 mv[-1] 0
map_clut[-1] [0] # Apply CLUT
-d v - # if all went well, then last 2 images should be almost identical!
rm[^0]
distribution3d colorcube3d primitives3d 1 add3d
v -